### FreeRTOS

#### 一、RTOS

##### 	1.1 综述

​		实时操作系统（Real-time operating system, RTOS），又称即时操作系统，它会按照排序运行、管理系统资源，并为开发应用程序提供一致的基础。

​		实时操作系统与一般的操作系统相比，最大的特色就是“实时性”，如果有一个任务需要执行，实时操作系统会马上（在较短时间内）执行该任务，不会有较长的延时。这种特性保证了各个任务的及时执行。

​		设计实时操作系统的首要目标不是高的吞吐量，而是保证任务在特定时间内完成，因此衡量一个实时操作系统坚固性的重要指标，是系统从接收一个任务，到完成该任务所需的时间，其时间的变化称为抖动。可以依抖动将实时操作系统分为两种：**硬实时操作系统**及**软实时操作系统**，硬实时操作系统比软实时操作系统有更少的抖动：

​		硬实时操作系统必须使任务在确定的时间内完成。
​		软实时操作系统能让绝大多数任务在确定时间内完成。		

实时操作系统与一般的操作系统有着不同的调度算法。普通的操作系统的调度器对于线程优先级等方面的处理更加灵活；而实时操作系统追求最小的中断延时和线程切换延时。

通常都会有最基础的内核，以及外加上去的模块，像是文件系统、网络协议堆栈和应用、设备驱动程序等模块。

RTOS的内核通常会有：调度器、对象、服务。

##### 	1.2 设计理念

​		通常，实时操作系统分为两大类:

​		事件驱动型。当一个高优先级的任务需要执行时，系统会自动切换到这个任务。这种根据优先级调度任务的方式称为抢占式任务处理。
​		时间触发型。每个任务在各自设定好的的时间间隔内重复、轮流调度。
时间触发型设计往往比较严格地调度任务，具有更好的多任务处理能力。多个任务被不停地轮流调度，在宏观上，就相当于一个CPU同时执行多个任务。

##### 	1.2 名词解释

- 信号量：
- 互斥量:



#### 二、FreeRTOS应用

##### 	2.1 FreeRTOS简介



##### 	2.2 任务

###### 		2.2.1 什么是任务



###### 		2.2.2 任务的调度

- 抢占式

​        如果用户在 FreeRTOS 的配置文件 FreeRTOSConfig.h 中禁止使用时间片调度， 那么每个任务必须配置不同的优先级。当 FreeRTOS 多任务启动执行后，基本会按照如下的方式去执行：
​		首先执行的最高优先级的任务 Task1， Task1 会一直运行直到遇到系统阻塞式的 API 函数，比如延迟，事件标志等待，信号量等待，Task1 任务会被挂起，也就是释放 CPU 的执行权，让低优先级的任务得到执行。
​		FreeRTOS 操作系统继续执行任务就绪列表中下一个最高优先级的任务 Task2，Task2 执行过程中有两种情况：
​		Task1由于延迟时间到， 接收到信号量消息等方面的原因， 使得 Task1从挂起状态恢复到就绪态，在抢占式调度器的作用下，Task2 的执行会被 Task1 抢占。
​		Task2 会一直运行直到遇到系统阻塞式的 API 函数，比如延迟，事件标志等待，信号量等待， Task2任务会被挂起，继而执行就绪列表中下一个最高优先级的任务。
​		如果用户创建了多个任务并且采用抢占式调度器的话，基本都是按照上面两条来执行。 根据抢占式调度器，当前的任务要么被高优先级任务抢占，要么通过调用阻塞式 API 来释放 CPU 使用权让低优先级任务执行，没有用户任务执行时就执行空闲任务。

![](.\resource\20190326110455632.png)

​	**运行条件**

​		创建 3 个任务 Task1，Task2 和 Task3;
​		Task1 的优先级为 1，Task2 的优先级为 2，Task3 的优先级为 3。 FreeRTOS 操作系统是设置的数值越小任务优先级越低，故 Task3 的优先级最高，Task1 的优先级最低。

​		**运行过程描述如下：**

​		此时任务 Task1 在运行中，运行过程中由于 Task2 就绪，在抢占式调度器的作用下任务 Task2 抢占Task1 的执行。 Task2 进入到运行态，Task1 由运行态进入到就绪态。
​		任务 Task2 在运行中，运行过程中由于 Task3 就绪，在抢占式调度器的作用下任务 Task3 抢占 Task2的执行。 Task3 进入到运行态，Task2 由运行态进入到就绪态。
​		任务 Task3 运行过程中调用了阻塞式 API 函数，比如 vTaskDelay，任务 Task3 被挂起，在抢占式调度器的作用下查找到下一个要执行的最高优先级任务是 Task2，任务 Task2 由就绪态进入到运行态。
​		任务 Task2 在运行中，运行过程中由于 Task3 再次就绪，在抢占式调度器的作用下任务 Task3 抢占Task2 的执行。 Task3 进入到运行态，Task2 由运行态进入到就绪态。

- 时间片

​        在小型的嵌入式 RTOS 中，最常用的的时间片调度算法就是 Round-robin 调度算法。这种调度算法可以用于抢占式或者合作式的多任务中。另外，时间片调度适合用于不要求任务实时响应的情况。实现 Round-robin 调度算法需要给同优先级的任务分配一个专门的列表，用于记录当前就绪的任务，并为每个任务分配一个时间片（也就是需要运行的时间长度，时间片用完了就进行任务切换）。

![](.\resource\20190326114354395.png)

​		由最上面的Tick ISR（滴答定时器中断、时基中断）可知，时间片的长度为四个时基，滴答定时器中断在每个时基结束都会发生，时间片轮转调度可以设置时基的整数倍作为时间片的长度。
​		任务1、2、3为相同优先级的三个任务，在在时间片轮转的调度下有序执行，至于他们的执行顺序，这是由调度队列来调控的，一个任务出队（执行）后会被插入到队尾，这样就实现了多个任务的循环执行。
（1）任务3正在执行，时基中断发生，但任务3还没有到期
（2）任务3主动放弃剩下的时间片
（3）UCOSIII恢复任务1，因为它是调度队列中任务3的下一个任务
（4）任务1执行直到它的时间片到期
（5） （6） （7） （8）同上；

###### 2.2.3 任务相关API



##### 	2.3 时钟

##### 	2.4 队列

##### 	2.5 信号量

##### 	2.6 事件

##### 	2.7 内存管理

##### 	2.8 空闲任务与低功耗



#### 三、FreeRTOS源码详解

